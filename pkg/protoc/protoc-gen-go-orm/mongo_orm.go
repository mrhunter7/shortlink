package main

import (
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

func generateMongoFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + ".mongo.orm.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-orm. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-go-orm v" + version)
	g.P("// - protoc             ", protocVersion(gen))
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	g.P("import (")
	g.P("\"go.mongodb.org/mongo-driver/bson\"")
	g.P(")")

	processMongoFile(file, g)
}

func processMongoFile(file *protogen.File, g *protogen.GeneratedFile) {
	for _, message := range file.Messages {
		generateMongoStructForMessage(message, g)
	}
}

func generateMongoStructForMessage(message *protogen.Message, g *protogen.GeneratedFile) {
	// Generate the BuildFilter method
	structName := "Filter" + message.GoIdent.GoName
	g.P("type ", structName, " struct {")
	for _, field := range message.Fields {
		if field.Desc.IsList() || field.Desc.IsMap() {
			continue
		}

		fieldName := field.GoName
		goType := "*" + "StringFilterInput"
		g.P(fieldName, " ", goType, " `json:\"", strings.ToLower(fieldName), "\"`")
	}
	g.P("}")
	g.P()

	generateBuildMongoFilterMethod(g, structName, message.Fields)
}

func generateBuildMongoFilterMethod(g *protogen.GeneratedFile, structName string, fields []*protogen.Field) {
	g.P("func (f *", structName, ") BuildMongoFilter() bson.M {")
	g.P("if f == nil {")
	g.P("return nil")
	g.P("}")
	g.P("filter := bson.M{}")

	for _, field := range fields {
		if field.Desc.IsList() || field.Desc.IsMap() {
			continue
		}
		fieldName := field.GoName
		bsonFieldName := strings.ToLower(fieldName) // Adjust as per your field naming conventions
		g.P("if f.", fieldName, " != nil {")
		g.P("fieldFilter := bson.M{}")

		// Logic for each condition in the StringFilterInput struct
		g.P("if f.", fieldName, ".Eq != \"\" {")
		g.P("fieldFilter[\"$eq\"] = f.", fieldName, ".Eq")
		g.P("}")
		g.P("if f.", fieldName, ".Ne != \"\" {")
		g.P("fieldFilter[\"$ne\"] = f.", fieldName, ".Ne")
		g.P("}")
		g.P("if f.", fieldName, ".Lt != \"\" {")
		g.P("fieldFilter[\"$lt\"] = f.", fieldName, ".Lt")
		g.P("}")
		g.P("if f.", fieldName, ".Le != \"\" {")
		g.P("fieldFilter[\"$lte\"] = f.", fieldName, ".Le")
		g.P("}")
		g.P("if f.", fieldName, ".Gt != \"\" {")
		g.P("fieldFilter[\"$gt\"] = f.", fieldName, ".Gt")
		g.P("}")
		g.P("if f.", fieldName, ".Ge != \"\" {")
		g.P("fieldFilter[\"$gte\"] = f.", fieldName, ".Ge")
		g.P("}")

		// Handle Contains as an array
		g.P("if len(f.", fieldName, ".Contains) > 0 {")
		g.P("fieldFilter[\"$in\"] = f.", fieldName, ".Contains")
		g.P("}")

		// Handle NotContains as an array
		g.P("if len(f.", fieldName, ".NotContains) > 0 {")
		g.P("fieldFilter[\"$nin\"] = f.", fieldName, ".NotContains")
		g.P("}")

		g.P("if len(fieldFilter) > 0 {")
		g.P("filter[\"", bsonFieldName, "\"] = fieldFilter")
		g.P("}")
		g.P("}")
	}

	g.P("return filter")
	g.P("}")
}
