// Code generated by protoc-gen-go-orm. DO NOT EDIT.
// versions:
// - protoc-gen-go-orm v1.1.0
// - protoc             (unknown)
// source: infrastructure/rpc/sitemap/v1/sitemap.proto

package v1

import (
	"strings"
	"github.com/Masterminds/squirrel"
	"go.mongodb.org/mongo-driver/bson"
)

type FilterParseRequest struct {
	Url        *StringFilterInput `json:"url"`
	Pagination *Pagination        `json:"pagination,omitempty"`
}

func (f *FilterParseRequest) BuildFilter(query squirrel.SelectBuilder) squirrel.SelectBuilder {
	if f.Url != nil {
		if f.Url.Eq != "" {
			query = query.Where("url = ?", f.Url.Eq)
		}
		if f.Url.Ne != "" {
			query = query.Where("url <> ?", f.Url.Ne)
		}
		if f.Url.Lt != "" {
			query = query.Where("url < ?", f.Url.Lt)
		}
		if f.Url.Le != "" {
			query = query.Where("url <= ?", f.Url.Le)
		}
		if f.Url.Gt != "" {
			query = query.Where("url > ?", f.Url.Gt)
		}
		if f.Url.Ge != "" {
			query = query.Where("url >= ?", f.Url.Ge)
		}
		if f.Url.StartsWith != "" {
			query = query.Where("url LIKE '%' || ?", f.Url.StartsWith)
		}
		if f.Url.EndsWith != "" {
			query = query.Where("url LIKE ? || '%'", f.Url.EndsWith)
		}
		if len(f.Url.Contains) > 0 {
			containsQueries := []string{}
			containsArgs := []interface{}{}
			for _, v := range f.Url.Contains {
				if v != "" {
					containsQueries = append(containsQueries, "url LIKE ?")
					containsArgs = append(containsArgs, "%"+v+"%")
				}
			}
			if len(containsQueries) > 0 {
				query = query.Where("("+strings.Join(containsQueries, " OR ")+")", containsArgs...)
			}
		}
		if len(f.Url.NotContains) > 0 {
			notContainsQueries := []string{}
			notContainsArgs := []interface{}{}
			for _, v := range f.Url.NotContains {
				if v != "" {
					notContainsQueries = append(notContainsQueries, "url NOT LIKE ?")
					notContainsArgs = append(notContainsArgs, "%"+v+"%")
				}
			}
			if len(notContainsQueries) > 0 {
				query = query.Where("("+strings.Join(notContainsQueries, " OR ")+")", notContainsArgs...)
			}
		}
		if f.Url.IsEmpty {
			query = query.Where("url = '' OR url IS NULL")
		}
		if f.Url.IsNotEmpty {
			query = query.Where("url <> '' AND url IS NOT NULL")
		}
	}
	if f.Pagination != nil {
		if f.Pagination.Page > 0 && f.Pagination.Limit > 0 {
			offset := (f.Pagination.Page - 1) * f.Pagination.Limit
			query = query.Limit(uint64(f.Pagination.Limit)).Offset(uint64(offset))
		} else if f.Pagination.Limit > 0 {
			query = query.Limit(uint64(f.Pagination.Limit))
		}
	}
	return query
}
func (f *FilterParseRequest) BuildMongoFilter() bson.M {
	if f == nil {
		return nil
	}
	filter := bson.M{}
	if f.Url != nil {
		fieldFilter := bson.M{}
		if f.Url.Eq != "" {
			fieldFilter["$eq"] = f.Url.Eq
		}
		if f.Url.Ne != "" {
			fieldFilter["$ne"] = f.Url.Ne
		}
		if f.Url.Lt != "" {
			fieldFilter["$lt"] = f.Url.Lt
		}
		if f.Url.Le != "" {
			fieldFilter["$lte"] = f.Url.Le
		}
		if f.Url.Gt != "" {
			fieldFilter["$gt"] = f.Url.Gt
		}
		if f.Url.Ge != "" {
			fieldFilter["$gte"] = f.Url.Ge
		}
		if len(f.Url.Contains) > 0 {
			fieldFilter["$in"] = f.Url.Contains
		}
		if len(f.Url.NotContains) > 0 {
			fieldFilter["$nin"] = f.Url.NotContains
		}
		if len(fieldFilter) > 0 {
			filter["url"] = fieldFilter
		}
	}
	return filter
}
